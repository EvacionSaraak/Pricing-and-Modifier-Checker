<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pricing Checker - Daman Thiqa</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ§®</text></svg>">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="main-container">
        <!-- Header -->
        <div class="header-bar">
            <h1 class="h3 mb-0"><i class="bi bi-calculator"></i> Pricing Checker - Daman Thiqa</h1>
        </div>
        
        <!-- Main Content -->
        <div class="content-wrapper">
            <!-- Left Sidebar - Modifiers, Search, and Upload -->
            <div class="left-sidebar">
                <h5 class="mb-3">Price Modifiers</h5>
                <div id="modifiersList" class="mb-4">
                    <!-- Modifiers table will be dynamically populated here -->
                </div>
                
                <hr class="my-4">
                
                <!-- Price List Search Section -->
                <h5 class="mb-3">Price List Search</h5>
                <div class="mb-3">
                    <label for="priceSearch" class="form-label">Search by Code or Description</label>
                    <input type="text" class="form-control" id="priceSearch" placeholder="Type to search..." oninput="searchPrices()">
                </div>
                <div id="pricelistStatus" class="alert alert-info" style="display:none;"></div>
                
                <hr class="my-4">
                
                <!-- XML Upload Section -->
                <h5 class="mb-3">Upload XML Claims</h5>
                <div class="mb-3">
                    <label for="xmlFile" class="form-label">XML File</label>
                    <input type="file" class="form-control" id="xmlFile" accept=".xml">
                </div>
                <div class="d-grid gap-2">
                    <button class="btn btn-primary" onclick="processXML()">
                        <i class="bi bi-gear-fill"></i> Process Claims
                    </button>
                    <button class="btn btn-outline-secondary" onclick="toggleInvalidFilter()">
                        <i class="bi bi-funnel"></i> <span id="filterButtonText">Show Only Invalids</span>
                    </button>
                </div>
            </div>
            
            <!-- Right Content Area -->
            <div class="right-content">
                <!-- Price Search Results Section -->
                <div class="input-section">
                    <h5 class="mb-3">Price Search Results</h5>
                    <div class="table-responsive" style="max-height: 400px; overflow-y: auto;">
                        <table class="table table-striped table-hover table-sm" id="priceSearchResults">
                            <thead class="table-light sticky-top">
                                <tr>
                                    <th style="width: 120px;">Code</th>
                                    <th style="width: 300px;">Description</th>
                                    <th style="width: 100px;">Base Price</th>
                                    <th style="width: 100px;">Thiqa</th>
                                    <th style="width: 100px;">Low-End</th>
                                    <th style="width: 100px;">Basic</th>
                                </tr>
                            </thead>
                            <tbody id="priceSearchBody">
                                <tr>
                                    <td colspan="6" class="text-center text-muted">
                                        Type in the search box to find prices...
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
                
                <!-- Results Section -->
                <div class="results-section" id="resultsTable">
                    <h5 class="mb-3">Processing Results</h5>
                    <div id="summarySection" class="mb-3"></div>
                    <div class="table-responsive">
                        <table class="table table-striped table-hover" id="resultsTableData">
                            <thead class="table-dark">
                                <tr>
                                    <th>CLAIM ID</th>
                                    <th>TYPE</th>
                                    <th>CODE</th>
                                    <th>NET</th>
                                    <th>QUANTITY</th>
                                    <th>Clinician</th>
                                    <th>Expected Price</th>
                                    <th>Modifier</th>
                                    <th>Status</th>
                                </tr>
                            </thead>
                            <tbody id="resultsBody">
                                <!-- Results will be populated here -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script>
        // Constants
        const MAX_SEARCH_RESULTS = 50; // Maximum number of search results to display
        
        // Global variables
        let priceList = {}; // Will hold price data from Prices.xlsx
        let modifiers = [];
        let allPrices = []; // Array to hold all price records for searching
        let processedClaims = []; // Store processed claims for filtering
        let showOnlyInvalids = false; // Filter state
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initializeModifiers();
            loadPricesXLSX(); // Load Prices.xlsx on startup
        });
        
        // Initialize default modifiers based on code types
        function initializeModifiers() {
            modifiers = [
                { type: 'Medical', thiqa: 1.3, lowEnd: 1.0, basic: 1.0 },
                { type: 'Radiology', thiqa: 1.0, lowEnd: 1.0, basic: 1.0 },
                { type: 'Laboratory', thiqa: 1.0, lowEnd: 1.0, basic: 1.0 },
                { type: 'Physiotherapy', thiqa: 1.0, lowEnd: 1.0, basic: 1.0 },
                { type: 'OP E&M', thiqa: 1.3, lowEnd: 1.08, basic: 1.0 }
            ];
            renderModifiers();
        }
        
        // Determine code type based on code prefix
        function getCodeType(code) {
            if (!code) return null;
            const codeStr = code.toString();
            
            // Medical starts with 1, 2, 3, 4, 5, and 6
            if (/^[1-6]/.test(codeStr)) return 'Medical';
            
            // Radiology starts with 7
            if (codeStr.startsWith('7')) return 'Radiology';
            
            // Laboratory starts with 8
            if (codeStr.startsWith('8')) return 'Laboratory';
            
            // Physiotherapy starts with 97
            if (codeStr.startsWith('97')) return 'Physiotherapy';
            
            // OP E&M starts with 99
            if (codeStr.startsWith('99')) return 'OP E&M';
            
            return null;
        }
        
        // Get modifiers for a specific code
        function getModifiersForCode(code) {
            const codeType = getCodeType(code);
            if (!codeType) return null;
            
            return modifiers.find(m => m.type === codeType);
        }
        
        // Add new modifier
        
        // Load Prices.xlsx on startup
        async function loadPricesXLSX() {
            try {
                const response = await fetch('Prices.xlsx');
                if (response.ok) {
                    const arrayBuffer = await response.arrayBuffer();
                    const data = new Uint8Array(arrayBuffer);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(firstSheet);
                    
                    // Process the data
                    processLoadedPrices(jsonData);
                    showPricelistStatus('Prices.xlsx loaded successfully! ' + allPrices.length + ' items available.', 'success');
                } else {
                    console.error('Could not load Prices.xlsx');
                    showPricelistStatus('Could not load Prices.xlsx', 'danger');
                }
            } catch (error) {
                console.error('Error loading Prices.xlsx:', error);
                showPricelistStatus('Error loading Prices.xlsx: ' + error.message, 'danger');
            }
        }
        
        // Process loaded price data
        function processLoadedPrices(jsonData) {
            allPrices = [];
            priceList = {};
            
            jsonData.forEach(row => {
                // Support both formats: Prices.xlsx format (Code, Code Description, Price (AED))
                // and the old format (Code, Name, Thiqa, High-end, etc.)
                const code = row.Code || row.code;
                
                // Find description column (handles variations in column names)
                const description = row['Code Description'] || row.Name || row.name || row.Description || '';
                
                // Find price column (handles variations including newline in column name)
                let basePrice = 0;
                for (const key in row) {
                    if (key.toLowerCase().includes('price') || key === 'Thiqa' || key === 'thiqa') {
                        basePrice = parseFloat(row[key]) || 0;
                        break;
                    }
                }
                
                if (code) {
                    const priceRecord = {
                        code: code,
                        description: description,
                        basePrice: basePrice
                    };
                    
                    allPrices.push(priceRecord);
                    priceList[code] = priceRecord;
                }
            });
        }
        
        // Search prices
        // Search prices
        function searchPrices() {
            const searchTerm = document.getElementById('priceSearch').value.toLowerCase().trim();
            const tbody = document.getElementById('priceSearchBody');
            
            if (!searchTerm) {
                tbody.innerHTML = '<tr><td colspan="6" class="text-center text-muted">Type in the search box to find prices...</td></tr>';
                return;
            }
            
            // Filter prices based on search term
            const filtered = allPrices.filter(item => 
                item.code.toLowerCase().includes(searchTerm) || 
                item.description.toLowerCase().includes(searchTerm)
            );
            
            if (filtered.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" class="text-center text-muted">No results found</td></tr>';
                return;
            }
            
            // Limit results for performance
            const displayResults = filtered.slice(0, MAX_SEARCH_RESULTS);
            
            tbody.innerHTML = displayResults.map(item => {
                const basePrice = item.basePrice;
                const codeModifiers = getModifiersForCode(item.code);
                
                // Calculate prices with modifiers
                const thiqaPrice = codeModifiers ? (basePrice * codeModifiers.thiqa).toFixed(2) : 'N/A';
                const lowEndPrice = codeModifiers ? (basePrice * codeModifiers.lowEnd).toFixed(2) : 'N/A';
                const basicPrice = codeModifiers ? (basePrice * codeModifiers.basic).toFixed(2) : 'N/A';
                
                return `
                    <tr>
                        <td>${escapeHtml(item.code)}</td>
                        <td>${escapeHtml(item.description)}</td>
                        <td>${basePrice.toFixed(2)}</td>
                        <td>${thiqaPrice}</td>
                        <td>${lowEndPrice}</td>
                        <td>${basicPrice}</td>
                    </tr>
                `;
            }).join('');
            
            if (filtered.length > MAX_SEARCH_RESULTS) {
                tbody.innerHTML += `<tr><td colspan="6" class="text-center text-muted">Showing ${MAX_SEARCH_RESULTS} of ${filtered.length} results. Refine your search for more specific results.</td></tr>`;
            }
        }
        
        // Update search results when modifiers change
        // Render modifiers table
        function renderModifiers() {
            const container = document.getElementById('modifiersList');
            
            const tableHTML = `
                <table class="modifiers-table">
                    <thead>
                        <tr>
                            <th>Type</th>
                            <th>Thiqa</th>
                            <th>Low-End</th>
                            <th>Basic</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${modifiers.map((mod, index) => `
                            <tr>
                                <td><strong>${mod.type}</strong></td>
                                <td><input type="number" step="0.01" value="${mod.thiqa}" onchange="updateModifier(${index}, 'thiqa', this.value)"></td>
                                <td><input type="number" step="0.01" value="${mod.lowEnd}" onchange="updateModifier(${index}, 'lowEnd', this.value)"></td>
                                <td><input type="number" step="0.01" value="${mod.basic}" onchange="updateModifier(${index}, 'basic', this.value)"></td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
            
            container.innerHTML = tableHTML;
            
            // Update search results with new modifier values
            searchPrices();
        }
        
        // Update modifier value
        function updateModifier(index, field, value) {
            modifiers[index][field] = parseFloat(value);
            searchPrices(); // Refresh search results with new modifier values
        }
        
        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Handle price list file upload
        document.getElementById('pricelistFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                        const jsonData = XLSX.utils.sheet_to_json(firstSheet);
                        
                        // Validate format - must have Code column
                        if (jsonData.length === 0) {
                            console.error('Error: File is empty');
                            showPricelistStatus('Error: File is empty', 'danger');
                            return;
                        }
                        
                        const firstRow = jsonData[0];
                        const hasCode = 'Code' in firstRow || 'code' in firstRow;
                        const hasDescription = 'Code Description' in firstRow || 'Name' in firstRow || 'name' in firstRow;
                        const hasPrice = 'Price \n(AED)' in firstRow || 'Price' in firstRow || 'Thiqa' in firstRow || 'thiqa' in firstRow;
                        
                        if (!hasCode) {
                            console.error('Error: Invalid format - missing Code column');
                            showPricelistStatus('Error: Invalid format - file must have a "Code" column', 'danger');
                            return;
                        }
                        
                        if (!hasDescription && !hasPrice) {
                            console.error('Error: Invalid format - missing description and price columns');
                            showPricelistStatus('Error: Invalid format - file must have description and/or price columns', 'danger');
                            return;
                        }
                        
                        // Process the data
                        processLoadedPrices(jsonData);
                        
                        showPricelistStatus('Price list uploaded successfully! ' + allPrices.length + ' items loaded.', 'success');
                        
                        // Clear search and refresh
                        document.getElementById('priceSearch').value = '';
                        searchPrices();
                    } catch (error) {
                        console.error('Error reading Excel file:', error);
                        showPricelistStatus('Error reading Excel file: ' + error.message, 'danger');
                    }
                };
                reader.readAsArrayBuffer(file);
            }
        });
        
        // Show pricelist status message
        function showPricelistStatus(message, type) {
            const statusDiv = document.getElementById('pricelistStatus');
            statusDiv.className = `alert alert-${type}`;
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 3000);
        }
        
        // Show general status message
        function showStatus(message, type) {
            // You can implement a toast or alert here
            console.log(message);
        }
        
        // Process XML file
        function processXML() {
            const xmlFile = document.getElementById('xmlFile').files[0];
            
            if (!xmlFile) {
                alert('Please select an XML file');
                return;
            }
            
            if (Object.keys(priceList).length === 0) {
                alert('Please upload a price list first');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const xmlText = e.target.result;
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                    
                    // Check for parsing errors
                    const parserError = xmlDoc.querySelector('parsererror');
                    if (parserError) {
                        alert('Error parsing XML file');
                        return;
                    }
                    
                    // Parse claims from XML
                    const claims = parseXMLClaims(xmlDoc);
                    
                    // Process and display results
                    displayResults(claims);
                } catch (error) {
                    alert('Error processing XML: ' + error.message);
                }
            };
            reader.readAsText(xmlFile);
        }
        
        // Parse claims from XML document
        // Parse claims from XML document
        function parseXMLClaims(xmlDoc) {
            const claims = [];
            
            // Handle both generic and HAAD-specific XML formats
            const claimElements = xmlDoc.querySelectorAll('Claim, claim');
            
            claimElements.forEach(claimEl => {
                const claimId = claimEl.querySelector('ID')?.textContent || 
                               claimEl.querySelector('ClaimID')?.textContent || 
                               claimEl.querySelector('claimId')?.textContent || 'N/A';
                
                // Get encounter type if available
                const encounterType = claimEl.querySelector('Encounter Type')?.textContent || 'N/A';
                
                // Get activities/services within the claim
                const activities = claimEl.querySelectorAll('Activity, activity, Service, service, Item, item');
                
                activities.forEach(activity => {
                    const claim = {
                        claimId: claimId,
                        type: encounterType,
                        code: activity.querySelector('Code')?.textContent || 
                              activity.querySelector('code')?.textContent || 
                              activity.querySelector('ServiceCode')?.textContent || 
                              activity.querySelector('ActivityCode')?.textContent || 'N/A',
                        net: parseFloat(activity.querySelector('Net')?.textContent || 
                                       activity.querySelector('net')?.textContent || 
                                       activity.querySelector('NetAmount')?.textContent || 
                                       activity.querySelector('Amount')?.textContent || '0'),
                        quantity: parseInt(activity.querySelector('Quantity')?.textContent || 
                                          activity.querySelector('quantity')?.textContent || 
                                          activity.querySelector('Qty')?.textContent || '1'),
                        clinician: activity.querySelector('Clinician')?.textContent || 
                                  activity.querySelector('clinician')?.textContent || 
                                  activity.querySelector('Doctor')?.textContent || 
                                  activity.querySelector('Provider')?.textContent || 
                                  activity.querySelector('OrderingClinician')?.textContent || 'N/A'
                    };
                    claims.push(claim);
                });
            });
            
            return claims;
        }
        
        // Display results in table
        // Display results in table
        function displayResults(claims) {
            processedClaims = claims; // Store for filtering
            renderResults();
        }
        
        // Render results (with optional filtering)
        function renderResults() {
            const claims = showOnlyInvalids ? 
                processedClaims.filter(claim => {
                    const result = checkPriceMatch(claim);
                    return result.status !== 'Match';
                }) : 
                processedClaims;
            
            const tbody = document.getElementById('resultsBody');
            tbody.innerHTML = '';
            
            let matchCount = 0;
            let mismatchCount = 0;
            let notFoundCount = 0;
            
            claims.forEach(claim => {
                const result = checkPriceMatch(claim);
                const row = tbody.insertRow();
                
                // Apply row styling based on match status
                if (result.status === 'Match') {
                    row.className = 'match-success';
                    matchCount++;
                } else if (result.status === 'Not Found') {
                    row.className = 'match-warning';
                    notFoundCount++;
                } else {
                    row.className = 'match-danger';
                    mismatchCount++;
                }
                
                row.innerHTML = `
                    <td>${claim.claimId}</td>
                    <td>${claim.type}</td>
                    <td>${claim.code}</td>
                    <td>${claim.net.toFixed(2)}</td>
                    <td>${claim.quantity}</td>
                    <td>${claim.clinician}</td>
                    <td>${result.expectedPrice !== null ? result.expectedPrice.toFixed(2) : 'N/A'}</td>
                    <td>${result.matchedModifier || 'N/A'}</td>
                    <td><span class="badge ${result.status === 'Match' ? 'bg-success' : result.status === 'Not Found' ? 'bg-warning' : 'bg-danger'}">${result.status}</span></td>
                `;
            });
            
            // Show summary (always show total from all claims)
            const allMatchCount = processedClaims.filter(c => checkPriceMatch(c).status === 'Match').length;
            const allMismatchCount = processedClaims.filter(c => checkPriceMatch(c).status === 'Mismatch').length;
            const allNotFoundCount = processedClaims.filter(c => checkPriceMatch(c).status === 'Not Found').length;
            
            const summaryDiv = document.getElementById('summarySection');
            summaryDiv.innerHTML = `
                <div class="alert alert-info">
                    <strong>Summary:</strong> 
                    Total Claims: ${processedClaims.length} | 
                    <span class="text-success">Matches: ${allMatchCount}</span> | 
                    <span class="text-danger">Mismatches: ${allMismatchCount}</span> | 
                    <span class="text-warning">Not Found: ${allNotFoundCount}</span>
                    ${showOnlyInvalids ? ' <em>(Showing filtered results: ' + claims.length + ' items)</em>' : ''}
                </div>
            `;
            
            // Show results table
            document.getElementById('resultsTable').style.display = 'block';
        }
        
        // Toggle invalid filter
        function toggleInvalidFilter() {
            showOnlyInvalids = !showOnlyInvalids;
            const buttonText = document.getElementById('filterButtonText');
            buttonText.textContent = showOnlyInvalids ? 'Show All Results' : 'Show Only Invalids';
            
            if (processedClaims.length > 0) {
                renderResults();
            }
        }
        
        // Check if price matches with any modifier
        function checkPriceMatch(claim) {
            const code = claim.code;
            const actualPrice = claim.net;
            
            // Check if code exists in price list and has basePrice
            if (!priceList[code] || !priceList[code].basePrice) {
                return {
                    status: 'Not Found',
                    expectedPrice: null,
                    matchedModifier: null
                };
            }
            
            const basePrice = priceList[code].basePrice;
            const codeModifiers = getModifiersForCode(code);
            
            if (!codeModifiers) {
                return {
                    status: 'Not Found',
                    expectedPrice: null,
                    matchedModifier: 'Unknown code type'
                };
            }
            
            // Try to match with each modifier type (thiqa, lowEnd, basic)
            const modifierTypes = [
                { name: 'Thiqa', value: codeModifiers.thiqa },
                { name: 'Low-End', value: codeModifiers.lowEnd },
                { name: 'Basic', value: codeModifiers.basic }
            ];
            
            for (let modType of modifierTypes) {
                const expectedPrice = basePrice * modType.value;
                
                // Allow small tolerance for floating point comparison
                if (Math.abs(actualPrice - expectedPrice) < 0.01) {
                    return {
                        status: 'Match',
                        expectedPrice: expectedPrice,
                        matchedModifier: `${modType.name} (${modType.value})`
                    };
                }
            }
            
            // No match found
            return {
                status: 'Mismatch',
                expectedPrice: basePrice * codeModifiers.thiqa,
                matchedModifier: null
            };
        }
    </script>
</body>
</html>
